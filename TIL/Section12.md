# 리액트 백그라운드 살펴보기와 리액트 최적화

react-optimize

- 리액트가 어떻게 컴포넌트와 연동 되는지
- 리액트가 어떻게 컴포넌트를 업데이트 하는지
- 상태 객체는 모든 것과 어떻게 관련이 있는지
- 가상 DOM과 작동 원리
- 상태 객체 관리

## 리액트가 실제로 작동하는 방식

잊지 말아야 할 리액트의 역할: 사용자 인터페이스 구축
리액트의 핵심: 컴포넌트

리액트: 컴포넌트를 관리하고 상태 객체를 관리하고 또한 다른 객체의 상태와 컴포넌트가 바뀌어야 하는지를 확인하고 컴포넌트의 변경 전후의 상태를 확인하는 라이브러리
리액트 DOM: 웹에 대한 인터페이스 (리액트는 웹을 모른다, 브라우저와 관계가 없다. => 컴포넌트는 어떻게 다루는지 알고 있지만 컴포넌트에 HTML 요소들이 포함되어 있는지에 대해서는 상관할 것이 아니다. 이는 리액트 DOM이 고려)

props -> component -> realDOM
상태변경은 컴포넌트 함수를 재실행 시킨다
컴포넌트가 재실행되면 모든 자식 컴포넌트들 역시 재실행, 재평가 된다.

React는 Component를 어떻게 다루는지에 대해 집중하고, React-Dom은 Component에 어떤 HTML 요소들이 포함되어 있는지, 컴포넌트 내부에 어떤 허구적인 요소들이 있는지 탐색한다.
이는 실제 HTML 요소들을 화면에 표시해주는 역할을 하는 것이 React-DOM이기 떄문이다.

React는 Component 관리에 대해 집중한다고 하였는데, React가 UI를 구성하기 위해 하는 일은 다음과 같다

> Component 관리
> State object 관리
> 다른 Object의 State와 Component가 바뀌어야 하는지를 확인.
> Component의 내부 데이터가 변경 된 뒤, 변경 전후 State 확인
> React는 위와 같이 관리하는 항목에서 변경 내용이 생긴다면,
> 화면에 표시되어야 할 정보를 React-DOM에 전달한다.

다시 한 번 강조하자면, **React-DOM**은 Browser의 일부인 **실제 DOM에 대한 작업**을 하며, 사용자가 보고 있는 화면을 보여주는 역할을 한다.

React가 관리하는 내용 중 핵심 기능은 다음과 같다.

> - Props : Component에 전달하는 Data로 Component 구성을 가능하게 해주며, 부모-자식 Component 간 Data를 연결해준다.

- State : Component 내부의 Data를 뜻한다.
- Context : 앱을 구성하는 전체 Component의 Data를 뜻한다.
- Component : 위 기능들의 집합인 Function이다.

Props,State,Context가 변경되면 React는 변경점이 발생되어 적용되는 Component가 화면에 새로운 것을 표시하는 것인지 확인하여 React-DOM에 이를 알려 리액트 DOM이 새로운 화면과 새로운 Component, 그리고 새로운 Rendering을 할 수 있게 알려준다.

그렇다면 React-DOM이 Component의 변경 내용을 전달 받은 뒤, 실제 DOM을 통해 Rendering을 진행할 때, React-DOM은 Brower와 어떻게 서로 통신을 주고 받을까?

> React는 Component를 다루며 최종적으로 가상 DOM이라는 개념을 사용한다.

가상 DOM은 어플리케이션이 마지막에 만들어내는 컴포넌트 트리를 결정한다.

Component는 JSX를 반환하는데, 이때 가상 DOM은 Component 트리의 현재 형태과 최종 형태를 비교한 뒤 트리의 모양을 결정한다.

만약 State가 업데이트 되었다면, 업데이트 정보는 React-DOM으로 전달되어 갱신 전후의 State 변경점을 확인하고, React가 Component 트리를 통해 구성한 가상 DOM과 일치하도록 실제 DOM을 조작하는 방법을 알 수 있게 한다.

갱신 전후의 상태 차이를 인식하고 리액트가 컴포넌트 트리를 통해 구성한 가상의 스냅샷인 가상 DOM과 일치하도록 실제 DOM을 조작한다.

> 1. Props,Context,state의 변경사항 발생
> 2. React가 컴포넌트 함수를 재실행 함.
> 3. React가 이를 재평가하게 되는 시스템이다.

Component 함수가 재실행된다고 해서 무조건 재평가로 이어지지 않는다
재평가라는 것이 꼭 DOM을 re-rendering하는 것은 아니다

리액트는 가상 DOM과의 비교를 통해 최종 스냅샷과 현재의 스냅샷을 실제 DOM에 전달하는 구조를 가지며 가상 DOM을 통해 2개의 스냅샷 간의 차이점을 알아낸다.
-> Reconciliation

## useMemo(): 특정한 상황에서 리액트 재실행 시키기

특정상황: 컴포넌트가 받은 prop변경된 경우

React.memo: 컴포넌트에 어떤 props가 입력되는지 확인하고 입력되는 모든 props의 신규 값을 확인한 뒤, 이를 기존의 props의 값과 비교하도록 리액트에게 전달한다.
그리고 props의 값이 바뀐 경우에만 컴포넌트를 재실행 및 재평가하게 된다.

React.memo를 모든 컴포넌트에 적용해서 최적화를 하면 안되나요?
-> 최적화에는 비용이 따르기 때문에 적절하지 않다.
memo 메소드는 앱에 변경이 발생할 때마다 해당 컴포넌트로 이동하여 props의 값과 새로운 값을 비교한다.
이를 위해 두가지가 필요하다.

1. 기존 props를 저장할 공간
2. 비교하는 작업

따라서 어떤 컴포넌트에 memo메소드를 사용해서 최적화하느냐가 중요
컴포넌트를 재평가하는데 필요한 성능과 props를 비교하는 비용을 계산해봐야한다.
이는 props의 개수, 컴포넌트의 복잡도, 자식 컴포넌트의 숫자에 따라 달라진다.
자식 컴포넌트가 매우 많은 경우에는 React.memo가 유용
그러나 부모 컴포넌트를 매 번 재평가 할 때마다 컴포넌트의 변화가 있는 경우라면 React.memo는 그다지 효율적이지 못하다 -> 재렌더링이 계속일어나니까

## useCallback(): 컴포넌트 실행 전반에 걸쳐 함수를 저장할 수 있게 하는 훅

리액트에 함수를 저장하고 매번 실행할 때마다 함수를 재생성할 필요가 없다는 것을 알림
-> 동일한 함수 객체가 메모리의 동일한 위치에 저장되므로 비교 작업 가능

### 사용법

저장하려는 함수를 useCallback Hook으로 래핑

```js
useCallback(Fn, dependancy);
```

### useCallback의 의존성 배열

리렌더링이 될 때 마다 항상 같은 함수를 사용하는데 왜 의존성 배열이 필요할까?
-> 클로져의 특징 때문에

자바스크립트의 함수는 클로저이다.
함수가 정의 될 때 함수 안에서 사용되는 함수 외부의 모든 변수를 잠그게 된다.
함수를 정의할 떄 사용하기 위해 변수를 저장한다. -> 변수의 값은 변수가 저장된 시점의 값을 사용하게된다.

문제는 useCallback을 사용하여 재평가 재실행을 막고 있다.
-> 따라서 의존성 배열에 변화를 감지해야할 변수를 추가해야 변수의 최신 값을 사용할 수 있다.

---

## Compmnets & State

리액트에서 state는 가장 중요함 개념

상태는 Compmnets를 리렌더링하고 화면에 표시되는 것을 바꾼다.
-> Compmnets와 state의 상호작용은 리액트의 핵심 개념

Compmnets와 state를 리액트가 관리한다는것에 주목할 필요가 있다.

### useState

가장 일반적인 state 관리 방법

새로운 상태를 만들어서 자동적으로 useState를 호출한 컴포넌트에 연결
리액트는 useState를 호출하게 되면 이를 관리하고 컴포넌트와 묶어줄 새로운 상태변수를 만든다.

리액트는 useState와 전달된 기본값에 대해서는 한 번만 고려되도록 처리한다.
즉, 컴포넌트가 최초 실행될 때만 새로운 상태변수를 만든다
그리고 어떤 컴포넌트에 state가 속하는지 기억해둔다.

재평가되는 과정에서 useState는 상태가 이미 존재함을 인식하고 필요할 경우에 상태를 업데이트 한다.
-> 리액트는 state의 관리와 갱신만 담당한다.

컴포넌트가 DOM에서 완전히 삭제되거나 하지 않는 이상 상태 초기화는 이뤄지지 않는다.

## State updates & scheduling

리액트가 상태 갱신을 어떻게 하는지 알 필요가 있다.

컴포넌트가 있고 useState로 상태를 관리한다.
사용자가 버튼을 누르는 등 작동으로 인해 컴포넌트 안에서 상태가 갱신된다.
**상태변경 함수가 실행되고 완료 되면 상태가 바로 변경 되지 않는다**
대신 상태 변경 업데이트를 하도록 예약을 한다.

보통, input에 사용자 입력에 응답하는 것이 화면의 문자를 변경하는 것보다 우선순위가 높을 것이다.
이러한 이유로 리액트는 상태변경을 연기할 수 있다.
상태 변화의 순서를 명확히 해서, 같은 타입임을 보증한다.

스케줄링 때문에 다수의 예약 상태 변화가 동시에 있을 수 있다.
그러므로 상태를 갱신할 때는 함수 형태를 이용해서 갱신하는 것을 추천한다. 특히, 이전 상태의 스냅샷에 의존해야 한다면 더욱

안전한 방법으로 상태변경을 하지 않으면 마지막으로 실행될 때 상태를 얻는데 의도하지 않은 결과를 얻을 수 있다.

함수 형태를 사용하면 리액트가 미완료 된 상태 변경 작업에 대해 최신 상태를 사용하고 컴포넌트가 재 렌더링 되었을 그 시점의 상태를 사용하지 않게 된다.

재렌더링이 되었을 때의 시점과 상태변경이 예약되는 시점의 차이 아는 것이 중요

useEffect는 상태 또는 종속된 값이 변경될 때 마다 의존성 메커니즘을 통해 내부에서 선언한 이펙트가 재실행 되게한다.

따라서 컴포넌트 함수가 재실행되고 컴포넌트가 재실행되므로 매번 이펙트가 다시 실행되기 때문에 미완료된 상태 변경 작업이 빠짐없이 실행된다.

-> 데이터 없이 작업을 할 수 있는 경우를 방지하기위해 함수형태나 useEffect를 사용할때 상태 갱신 스케줄링을 꼭 알아야한다.

### 정리

상태업데이트함수를 호출한다고 바로 상태가 갱신되는 것이 아니다.
상태 갱신 예약을 할 뿐이다.
리액트는 상태 갱신 함수들의 상태 갱신을 하나의 동기화 프로세스에서 같이 실행한다.
예를 들어, 하나의 함수가 처음부터 끝까지 어떠한 콜백이나 프로미스 없이 실행된다면 이럴 때 리액트는 이함수로 부터 발생하는 모든 상태 갱신 작업을 하나의 상태 갱신 작업으로 처리한다.

즉 여러개의 상태를 변경하는 하나의 상태 변경 작업 스케줄이 존재하는 것이다.

---

## 더 공부할 것

JS closure

168강. 함수형태를 사용하는 이유
